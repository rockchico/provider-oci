// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DestinationInitParameters struct {

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The hostnames of the external service. Only applicable for HTTP and HTTPS protocols. Wildcard hostnames are supported in the prefix form. Examples of valid hostnames are "www.example.com", ".example.com", ".com", "". Hostname "" can be used to allow all hosts.
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The ipAddresses of the external service in CIDR notation. Only applicable for TCP protocol. All requests matching the given CIDR notation will pass through. In case a wildcard CIDR "0.0.0.0/0" is provided, the same port cannot be used for a virtual service communication.
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// (Updatable) The OCID of the ingress gateway resource.
	IngressGatewayID *string `json:"ingressGatewayId,omitempty" tf:"ingress_gateway_id,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Ports exposed by an external service. If left empty all ports will be allowed.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Protocol of the external service
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// (Updatable) Traffic type of the target.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) The OCID of the virtual service resource.
	VirtualServiceID *string `json:"virtualServiceId,omitempty" tf:"virtual_service_id,omitempty"`
}

type DestinationObservation struct {

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The hostnames of the external service. Only applicable for HTTP and HTTPS protocols. Wildcard hostnames are supported in the prefix form. Examples of valid hostnames are "www.example.com", ".example.com", ".com", "". Hostname "" can be used to allow all hosts.
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The ipAddresses of the external service in CIDR notation. Only applicable for TCP protocol. All requests matching the given CIDR notation will pass through. In case a wildcard CIDR "0.0.0.0/0" is provided, the same port cannot be used for a virtual service communication.
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// (Updatable) The OCID of the ingress gateway resource.
	IngressGatewayID *string `json:"ingressGatewayId,omitempty" tf:"ingress_gateway_id,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Ports exposed by an external service. If left empty all ports will be allowed.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Protocol of the external service
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// (Updatable) Traffic type of the target.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) The OCID of the virtual service resource.
	VirtualServiceID *string `json:"virtualServiceId,omitempty" tf:"virtual_service_id,omitempty"`
}

type DestinationParameters struct {

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The hostnames of the external service. Only applicable for HTTP and HTTPS protocols. Wildcard hostnames are supported in the prefix form. Examples of valid hostnames are "www.example.com", ".example.com", ".com", "". Hostname "" can be used to allow all hosts.
	// +kubebuilder:validation:Optional
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The ipAddresses of the external service in CIDR notation. Only applicable for TCP protocol. All requests matching the given CIDR notation will pass through. In case a wildcard CIDR "0.0.0.0/0" is provided, the same port cannot be used for a virtual service communication.
	// +kubebuilder:validation:Optional
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// (Updatable) The OCID of the ingress gateway resource.
	// +kubebuilder:validation:Optional
	IngressGatewayID *string `json:"ingressGatewayId,omitempty" tf:"ingress_gateway_id,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Ports exposed by an external service. If left empty all ports will be allowed.
	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Protocol of the external service
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// (Updatable) Traffic type of the target.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// (Updatable) The OCID of the virtual service resource.
	// +kubebuilder:validation:Optional
	VirtualServiceID *string `json:"virtualServiceId,omitempty" tf:"virtual_service_id,omitempty"`
}

type MeshAccessPolicyInitParameters struct {

	// (Updatable) The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Description of the resource. It can be changed after creation. Avoid entering confidential information.  Example: This is my new resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the service mesh in which this access policy is created.
	MeshID *string `json:"meshId,omitempty" tf:"mesh_id,omitempty"`

	// A user-friendly name. The name has to be unique within the same service mesh and cannot be changed after creation. Avoid entering confidential information.  Example: My unique resource name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Updatable) List of applicable rules
	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type MeshAccessPolicyObservation struct {

	// (Updatable) The OCID of the compartment.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Description of the resource. It can be changed after creation. Avoid entering confidential information.  Example: This is my new resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// Unique identifier that is immutable on creation.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in a Failed state.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// The OCID of the service mesh in which this access policy is created.
	MeshID *string `json:"meshId,omitempty" tf:"mesh_id,omitempty"`

	// A user-friendly name. The name has to be unique within the same service mesh and cannot be changed after creation. Avoid entering confidential information.  Example: My unique resource name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Updatable) List of applicable rules
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`

	// The current state of the Resource.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// Usage of system tag keys. These predefined keys are scoped to namespaces. Example: {"orcl-cloud.free-tier-retained": "true"}
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The time when this resource was created in an RFC3339 formatted datetime string.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// The time when this resource was updated in an RFC3339 formatted datetime string.
	TimeUpdated *string `json:"timeUpdated,omitempty" tf:"time_updated,omitempty"`
}

type MeshAccessPolicyParameters struct {

	// (Updatable) The OCID of the compartment.
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: {"foo-namespace.bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) Description of the resource. It can be changed after creation. Avoid entering confidential information.  Example: This is my new resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: {"bar-key": "value"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the service mesh in which this access policy is created.
	// +kubebuilder:validation:Optional
	MeshID *string `json:"meshId,omitempty" tf:"mesh_id,omitempty"`

	// A user-friendly name. The name has to be unique within the same service mesh and cannot be changed after creation. Avoid entering confidential information.  Example: My unique resource name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Updatable) List of applicable rules
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type RulesInitParameters struct {

	// (Updatable) Action for the traffic between the source and the destination.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Updatable) Target of the access policy. This can either be the source or the destination of the traffic.
	Destination []DestinationInitParameters `json:"destination,omitempty" tf:"destination,omitempty"`

	// (Updatable) Target of the access policy. This can either be the source or the destination of the traffic.
	Source []SourceInitParameters `json:"source,omitempty" tf:"source,omitempty"`
}

type RulesObservation struct {

	// (Updatable) Action for the traffic between the source and the destination.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Updatable) Target of the access policy. This can either be the source or the destination of the traffic.
	Destination []DestinationObservation `json:"destination,omitempty" tf:"destination,omitempty"`

	// (Updatable) Target of the access policy. This can either be the source or the destination of the traffic.
	Source []SourceObservation `json:"source,omitempty" tf:"source,omitempty"`
}

type RulesParameters struct {

	// (Updatable) Action for the traffic between the source and the destination.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// (Updatable) Target of the access policy. This can either be the source or the destination of the traffic.
	// +kubebuilder:validation:Optional
	Destination []DestinationParameters `json:"destination" tf:"destination,omitempty"`

	// (Updatable) Target of the access policy. This can either be the source or the destination of the traffic.
	// +kubebuilder:validation:Optional
	Source []SourceParameters `json:"source" tf:"source,omitempty"`
}

type SourceInitParameters struct {

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The hostnames of the external service. Only applicable for HTTP and HTTPS protocols. Wildcard hostnames are supported in the prefix form. Examples of valid hostnames are "www.example.com", ".example.com", ".com", "". Hostname "" can be used to allow all hosts.
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The ipAddresses of the external service in CIDR notation. Only applicable for TCP protocol. All requests matching the given CIDR notation will pass through. In case a wildcard CIDR "0.0.0.0/0" is provided, the same port cannot be used for a virtual service communication.
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// (Updatable) The OCID of the ingress gateway resource.
	IngressGatewayID *string `json:"ingressGatewayId,omitempty" tf:"ingress_gateway_id,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Ports exposed by an external service. If left empty all ports will be allowed.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Protocol of the external service
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// (Updatable) Traffic type of the target.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) The OCID of the virtual service resource.
	VirtualServiceID *string `json:"virtualServiceId,omitempty" tf:"virtual_service_id,omitempty"`
}

type SourceObservation struct {

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The hostnames of the external service. Only applicable for HTTP and HTTPS protocols. Wildcard hostnames are supported in the prefix form. Examples of valid hostnames are "www.example.com", ".example.com", ".com", "". Hostname "" can be used to allow all hosts.
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The ipAddresses of the external service in CIDR notation. Only applicable for TCP protocol. All requests matching the given CIDR notation will pass through. In case a wildcard CIDR "0.0.0.0/0" is provided, the same port cannot be used for a virtual service communication.
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// (Updatable) The OCID of the ingress gateway resource.
	IngressGatewayID *string `json:"ingressGatewayId,omitempty" tf:"ingress_gateway_id,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Ports exposed by an external service. If left empty all ports will be allowed.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Protocol of the external service
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// (Updatable) Traffic type of the target.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Updatable) The OCID of the virtual service resource.
	VirtualServiceID *string `json:"virtualServiceId,omitempty" tf:"virtual_service_id,omitempty"`
}

type SourceParameters struct {

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The hostnames of the external service. Only applicable for HTTP and HTTPS protocols. Wildcard hostnames are supported in the prefix form. Examples of valid hostnames are "www.example.com", ".example.com", ".com", "". Hostname "" can be used to allow all hosts.
	// +kubebuilder:validation:Optional
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) The ipAddresses of the external service in CIDR notation. Only applicable for TCP protocol. All requests matching the given CIDR notation will pass through. In case a wildcard CIDR "0.0.0.0/0" is provided, the same port cannot be used for a virtual service communication.
	// +kubebuilder:validation:Optional
	IPAddresses []*string `json:"ipAddresses,omitempty" tf:"ip_addresses,omitempty"`

	// (Updatable) The OCID of the ingress gateway resource.
	// +kubebuilder:validation:Optional
	IngressGatewayID *string `json:"ingressGatewayId,omitempty" tf:"ingress_gateway_id,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Ports exposed by an external service. If left empty all ports will be allowed.
	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// (Applicable when type=EXTERNAL_SERVICE) (Updatable) Protocol of the external service
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// (Updatable) Traffic type of the target.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// (Updatable) The OCID of the virtual service resource.
	// +kubebuilder:validation:Optional
	VirtualServiceID *string `json:"virtualServiceId,omitempty" tf:"virtual_service_id,omitempty"`
}

// MeshAccessPolicySpec defines the desired state of MeshAccessPolicy
type MeshAccessPolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MeshAccessPolicyParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider MeshAccessPolicyInitParameters `json:"initProvider,omitempty"`
}

// MeshAccessPolicyStatus defines the observed state of MeshAccessPolicy.
type MeshAccessPolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MeshAccessPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// MeshAccessPolicy is the Schema for the MeshAccessPolicys API. Provides the Access Policy resource in Oracle Cloud Infrastructure Service Mesh service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,provider-oci}
type MeshAccessPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.compartmentId) || (has(self.initProvider) && has(self.initProvider.compartmentId))",message="spec.forProvider.compartmentId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.meshId) || (has(self.initProvider) && has(self.initProvider.meshId))",message="spec.forProvider.meshId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.rules) || (has(self.initProvider) && has(self.initProvider.rules))",message="spec.forProvider.rules is a required parameter"
	Spec   MeshAccessPolicySpec   `json:"spec"`
	Status MeshAccessPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MeshAccessPolicyList contains a list of MeshAccessPolicys
type MeshAccessPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MeshAccessPolicy `json:"items"`
}

// Repository type metadata.
var (
	MeshAccessPolicy_Kind             = "MeshAccessPolicy"
	MeshAccessPolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MeshAccessPolicy_Kind}.String()
	MeshAccessPolicy_KindAPIVersion   = MeshAccessPolicy_Kind + "." + CRDGroupVersion.String()
	MeshAccessPolicy_GroupVersionKind = CRDGroupVersion.WithKind(MeshAccessPolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&MeshAccessPolicy{}, &MeshAccessPolicyList{})
}
